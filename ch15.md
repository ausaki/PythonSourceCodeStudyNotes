# Python 多线程机制

## GIL

GIL(Global Interpreter Lock, 全局解释器锁)，是 Python 内部多线程之间的一种互斥锁，为了保护在多线程之间共享的全局资源（例如引用计数器）。因为只有获得了 GIL 的线程才可以运行，所以 GIL 保证了同一时刻只有一个线程运行。另外，GIL 保证指令的原子性。

由于 GIL 的存在，Python 中的多线程无法利用多核 CPU，因为同一时刻只有一个线程可以运行，只能利用单个 CPU，其余 CPU 处于闲置状态。

GIL 的锁粒度比较大，对多线程的性能损耗较大。假如移除 GIL，转而使用细粒度的锁，只在访问共享资源时进行加锁操作，这样看起来可以提高多线程的效率，但是：

- 由于使用的锁较多，容易导致死锁。

- 由于使用的锁较多，频繁加锁 / 解锁，对单线程来说，性能低于 GIL 版本。

综合来看，GIL 是一种目前比较合适的多线程方案。

## 线程调度

- 当一个线程运行了一定数量的字节码之后，Python 将该线程挂起，唤醒别的线程。字节码的数量可以通过 `sys.getcheckinterval()` 获取。

- 当一个线程执行会阻塞的调用时，会主动释放 GIL。

## 线程实现

Python 中的线程是对操作系统的原生线程的封装，具体实现在 `threadmodule.c`

## Python3 修改了 GIL 的实现

- 使用互斥锁和条件变量实现 GIL。

- 当有线程尝试获取 GIL 时，如果 GIL 已经被别的线程占有，那么便阻塞在 GIL 的条件变量上直到发生超时。如果超时后线程仍然没有获取到GIL，那么就设置一个标志通知占有GIL的线程释放GIL，接着又阻塞在GIL的条件变量直到超时。

  当持有GIL的线程发现标志后，会释放掉 GIL。

  