# 协程

因为协程的实现和生成器有关, 所以关于生成器的实现查看[生成器](./生成器.md)

## 数据结构

PyCoroObject:

```c
/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
#define _PyGenObject_HEAD(prefix)                                           \
    PyObject_HEAD                                                           \
    /* Note: gi_frame can be NULL if the generator is "finished" */         \
    PyFrameObject *prefix##_frame;                                          \
    /* True if generator is being executed. */                              \
    char prefix##_running;                                                  \
    /* The code object backing the generator */                             \
    PyObject *prefix##_code;                                                \
    /* List of weak reference. */                                           \
    PyObject *prefix##_weakreflist;                                         \
    /* Name of the generator. */                                            \
    PyObject *prefix##_name;                                                \
    /* Qualified name of the generator. */                                  \
    PyObject *prefix##_qualname;                                            \
    _PyErr_StackItem prefix##_exc_state;

typedef struct {
    _PyGenObject_HEAD(cr)
    PyObject *cr_origin;
} PyCoroObject;
```

从 PyCoroObject 的定义可以看出它和生成器(PyGenObject)几乎相同的.


## 从一个简单的例子开始

Python 代码:

```py
import asyncio

async def f():
    await asyncio.sleep(5)
    return 10

print(f.__code__.co_flags)
print(asyncio.run(f()))
```

对应的字节码:

```
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (asyncio)
              6 STORE_NAME               0 (asyncio)

  3           8 LOAD_CONST               2 (<code object f at 0x7f06909329d0, file "mydemo/coro_demo.py", line 3>)
             10 LOAD_CONST               3 ('f')
             12 MAKE_FUNCTION            0
             14 STORE_NAME               1 (f)

  7          16 LOAD_NAME                2 (print)
             18 LOAD_NAME                0 (asyncio)
             20 LOAD_METHOD              3 (run)
             22 LOAD_NAME                1 (f)
             24 CALL_FUNCTION            0
             26 CALL_METHOD              1
             28 CALL_FUNCTION            1
             30 POP_TOP
             32 LOAD_CONST               1 (None)
             34 RETURN_VALUE

Disassembly of <code object f at 0x7f06909329d0, file "mydemo/coro_demo.py", line 3>:
  4           0 LOAD_GLOBAL              0 (asyncio)
              2 LOAD_METHOD              1 (sleep)
              4 LOAD_CONST               1 (5)
              6 CALL_METHOD              1
              8 GET_AWAITABLE
             10 LOAD_CONST               0 (None)
             12 YIELD_FROM
             14 POP_TOP

  5          16 LOAD_CONST               1 (10)
             18 RETURN_VALUE
```             

code 对象的 co_flags 等于 195(0xc3), 即等于 `CO_COROUTINE | CO_NOFREE | CO_NEWLOCALS | CO_OPTIMIZED`.

和协程相关的字节码有: `GET_AWAITABLE`. 

### async

async 关键字的作用其实就是标记函数是返回协程的函数, code 对象的 co_flags 中会添加 CO_COROUTINE. 这样一来就可以区分协程和生成器.

### async 生成新的协程对象(PyCoro_New)

调用 `f()` 会创建一个协程对象, 过程和创建生成器一样, 代码如下:

```c
/* Handle generator/coroutine/asynchronous generator */
if (co->co_flags & (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) {
    PyObject *gen;
    int is_coro = co->co_flags & CO_COROUTINE;

    /* Don't need to keep the reference to f_back, it will be set
      * when the generator is resumed. */
    Py_CLEAR(f->f_back);

    /* Create a new generator that owns the ready to run frame
      * and return that as the value. */
    if (is_coro) {
        gen = PyCoro_New(f, name, qualname);
    } else if (co->co_flags & CO_ASYNC_GENERATOR) {
        gen = PyAsyncGen_New(f, name, qualname);
    } else {
        gen = PyGen_NewWithQualName(f, name, qualname);
    }
    if (gen == NULL) {
        return NULL;
    }

    _PyObject_GC_TRACK(f);

    return gen;
}

retval = _PyEval_EvalFrame(tstate, f, 0);
```

```c
PyObject *
PyCoro_New(PyFrameObject *f, PyObject *name, PyObject *qualname)
{
    // 注意: gen_new_with_qualname 的作用是创建 PyGenObject, 但是因为 PyCoroObject 和 PyGenObject 几乎一样, 
    // PyCoroObject 在结构体尾部多了一个字段 cr_origin, 所以可以复用 gen_new_with_qualname 用于创建 PyCoroObject
    PyObject *coro = gen_new_with_qualname(&PyCoro_Type, f, name, qualname);
    if (!coro) {
        return NULL;
    }

    PyThreadState *tstate = _PyThreadState_GET();
    int origin_depth = tstate->coroutine_origin_tracking_depth;

    if (origin_depth == 0) {
        ((PyCoroObject *)coro)->cr_origin = NULL;
    } else {
        PyObject *cr_origin = compute_cr_origin(origin_depth);
        ((PyCoroObject *)coro)->cr_origin = cr_origin;
        if (!cr_origin) {
            Py_DECREF(coro);
            return NULL;
        }
    }

    return coro;
}
```

从上面的代码可以看出, `PyCoro_New` 使用 `gen_new_with_qualname` 创建了一个 PyCoroObject 对象, 接下来将最近 origin_depth 个的 frame 保存到 `coro->cr_origin` 中.

`compute_cr_origin` 获取最近的 origin_depth 个 frame 的信息.


### await

await 关键字对应的字节码为:

```
 8 GET_AWAITABLE
10 LOAD_CONST               0 (None)
12 YIELD_FROM
```

GET_AWAITABLE 对应的处理器:

```c
case TARGET(GET_AWAITABLE): {
    PREDICTED(GET_AWAITABLE);
    PyObject *iterable = TOP();
    PyObject *iter = _PyCoro_GetAwaitableIter(iterable);

    if (iter == NULL) {
        int opcode_at_minus_3 = 0;
        if ((next_instr - first_instr) > 2) {
            opcode_at_minus_3 = _Py_OPCODE(next_instr[-3]);
        }
        format_awaitable_error(tstate, Py_TYPE(iterable),
                                opcode_at_minus_3,
                                _Py_OPCODE(next_instr[-2]));
    }

    Py_DECREF(iterable);

    if (iter != NULL && PyCoro_CheckExact(iter)) {
        PyObject *yf = _PyGen_yf((PyGenObject*)iter);
        if (yf != NULL) {
            /* `iter` is a coroutine object that is being
                awaited, `yf` is a pointer to the current awaitable
                being awaited on. */
            // yf != NULL 说明 iter 已经被执行过了
            Py_DECREF(yf);
            Py_CLEAR(iter);
            _PyErr_SetString(tstate, PyExc_RuntimeError,
                              "coroutine is being awaited already");
            /* The code below jumps to `error` if `iter` is NULL. */
        }
    }

    SET_TOP(iter); /* Even if it's NULL */

    if (iter == NULL) {
        goto error;
    }

    PREDICT(LOAD_CONST);
    DISPATCH();
}
```

可以看出 await 的基本原理就是 `YIELD_FROM`, 这再一次说明协程和生成器的关系. `GET_AWAITABLE` 将协程放入到栈顶, `YIELD_FROM` 的 receiver 就是该协程.

## asyncio 模块



### eventloop

eventloop 的各种方法分类:

- 启动和关闭 loop

  - run_until_complete
  - run_forever
  - stop
  - close

- 定时任务

  - call_soon
  - call_soon_threadsafe
  - call_later
  - call_at

- 创建 future 和 task
  
  - create_future
  - create_task

- 网络操作

  - create_connection
  - create_datagram_endpoint
  - create_unix_connection
  - create_server
  - create_unix_server
  - connect_accepted_socket
  
- 监听文件描述符(I/O 复用)
  
  - add_reader
  - remove_reader
  - add_writer
  - remove_writer
  
- 直接操作 socket
  
  - sock_recv
  - sock_recv_into
  - sock_sendall
  - sock_connect
  - sock_accept
  - sock_sendfile

- DNS

  - getaddrinfo
  - getnameinfo

- pipe
  
  - connect_read_pipe
  - connect_write_pipe

- 信号
  
  - add_signal_handler
  - remove_signal_handler

- 使用线程池和进程池执行任务

  - run_in_executor
  - set_default_executor

- 异常处理
  
  - set_exception_handler
  - get_exception_handler
  - default_exception_handler
  - call_exception_handler

- 调试模式

  - get_debug
  - set_debug

- 子进程

  - subprocess_exec
  - subprocess_shell

[eventloop 的官方文档](https://docs.python.org/3/library/asyncio-eventloop.html)


### Future

### network


